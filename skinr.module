<?php
// $Id$

/**
 * @file
 * Handles core Skinr functionality.
 */

/**
 * Implements hook_help().
 */
function skinr_help($path, $arg) {
  switch ($path) {
    case 'admin/help#skinr':
      if (module_exists('advanced_help')) {
        return t('Visit the <a href="@skinr-help">help page</a> for full documentation.', array('@skinr-help' => url('admin/advanced_help/skinr')));
      }
      else {
        return t('Please download and enable the <a href="http://drupal.org/project/advanced_help">Advanced Help</a> module for full Skinr documentation.');
      }
      break;
  }
}

/**
 * Implements hook_module_implements_alter().
 */
function skinr_module_implements_alter(&$implementations, $hook) {
  // Run Skinr first to avoid issues with other modules during hook_init().
  if ($hook == 'init') {
    $skinr['skinr'] = $implementations['skinr'];
    unset($implementations['skinr']);
    $implementations = array_merge($skinr, $implementations);
  }
}

/**
 * Implements hook_init().
 */
function skinr_init() {
  module_load_include('inc', 'skinr', 'skinr.handlers');
  skinr_module_include('skinr.inc');
}

/**
 * Implements hook_preprocess().
 */
function skinr_preprocess(&$variables, $hook) {
  // Fix for update script.
  if ($hook == 'maintenance_page') {
    return;
  }

  $skinr_config = skinr_fetch_config();
  $current_theme = skinr_current_theme();
  $theme_registry = theme_get_registry();

  $original_hook = $hook;
  if (isset($theme_registry[$hook]['original hook'])) {
    $original_hook = $theme_registry[$hook]['original hook'];
  }

  foreach ($skinr_config as $module => $settings) {
    if (!empty($settings['preprocess'][$original_hook])) {
      $preprocess_settings = $settings['preprocess'][$original_hook];
      $sids = skinr_handler('preprocess_index_handler', 'preprocess', $preprocess_settings['index_handler'], $variables);

      if ($extracted = skinr_skin_extract($module, $sids, $settings, $current_theme)) {
        foreach ($extracted['css'] as $file) {
          if ($file['enabled']) {
            _skinr_add_file($file['path'], 'css', $file['media']);
          }
        }
        foreach ($extracted['js'] as $file) {
          if ($file['enabled']) {
            _skinr_add_file($file['path'], 'js');
          }
        }
        $variables['classes_array'] = array_merge($variables['classes_array'], $extracted['classes']);

        // Add a hook for skinr_ui to plug into: hook_skinr_preprocess_alter().
        $data = array(
          'hook' => $hook,
          'variables' => &$variables,
          'skin' => &$extracted,
        );
        drupal_alter('skinr_preprocess', $data);
      }
    }
  }
}

/**
 * Helper function to extract classes, JS and CSS files.
 *
 * @param $module
 *   The module these settings applies to.
 * @param $sids
 *   The settings ID, or an array of settings IDs.
 * @param $settings
 *   Skinr configuration data for the desired module.
 * @param $theme
 *   The theme these settings apply to. If no theme name is provided, the
 *   current theme will be used.
 *
 * @return
 *   An array containing the module, sids, classes, CSS, JS, template to be
 *   applied.
 */
function skinr_skin_extract($module, $sids, $settings, $theme = NULL) {
  if (empty($sids)) {
    return FALSE;
  }
  if (!is_array($sids)) {
    $sids = array($sids);
  }
  if (is_null($theme)) {
    $theme = skinr_current_theme();
  }

  $extracted = array(
    'module' => $module,
    'sids' => $sids,
    'classes' => array(),
    'css' => array(),
    'js' => array(),
  );

  $skins = array();
  foreach ($sids as $sid) {
    if ($skinr = skinr_get($theme, $module, $sid)) {
      $skins = $skinr->skins + $skins;
    }
  }

  // Allow other modules to alter the skinr skins array.
  // @todo Fix this to work with skinr ui.
  drupal_alter('skinr_skins', $skins, $module, $sids, $settings);

  $extracted['css'] = skinr_skin_get_files($skins, 'css', $theme);
  $extracted['js'] = skinr_skin_get_files($skins, 'js', $theme);

  $extracted['classes'] = skinr_flatten_skins_array($skins);

  return $extracted;
}

/**
 * Helper function to fetch all CSS or JS files from an array of skins.
 *
 * @param $skins
 *   A an array of available skins.
 * @param $type
 *   Either 'css' or 'js', depending on which files you wish to retrieve from
 *   these skins.
 * @param $theme
 *   The theme from which to grab these files. Defaults to the current theme.
 *
 * @return
 *   An array of file data.
 */
function skinr_skin_get_files($skins, $type, $theme = NULL) {
  if (empty($theme)) {
    $theme = skinr_current_theme();
  }

  $info = skinr_skin_data();
  $files = array();

  if ($type == 'css') {
    foreach ($skins as $skin => $classes) {
      // Add custom CSS files.
      if (isset($info[$theme]->skins[$skin])) {
        if (!empty($info[$theme]->skins[$skin]['stylesheets'])) {
          foreach ($info[$theme]->skins[$skin]['stylesheets'] as $media => $stylesheets) {
            foreach ($stylesheets as $file => $path) {
              $files[] = array(
                'file' => $file,
                'path' => $path,
                'media' => $media,
                'enabled' => TRUE,
                'skin' => $skin,
                'options' => 0,
              );
            }
          }
        }
        foreach ($info[$theme]->skins[$skin]['options'] as $option_id => $option) {
          if (!empty($option['stylesheets'])) {
            foreach ($option['stylesheets'] as $media => $stylesheets) {
              foreach ($stylesheets as $file => $path) {
                $enabled = FALSE;
                if (is_array($classes)) {
                  if (in_array($option['class'], $classes)) {
                    $enabled = TRUE;
                  }
                }
                else {
                  if ($option['class'] == $classes) {
                    $enabled = TRUE;
                  }
                }

                $files[] = array(
                  'file' => $file,
                  'path' => $path,
                  'media' => $media,
                  'enabled' => $enabled,
                  'skin' => $skin,
                  'options' => $option_id,
                );
              }
            }
          }
        }
      }
    }
  }
  elseif ($type == 'js') {
    foreach ($skins as $skin => $classes) {
      // Add custom JS files.
      if (isset($info[$theme]->skins[$skin])) {
        if (isset($info[$theme]->skins[$skin]['scripts'])) {
          foreach ($info[$theme]->skins[$skin]['scripts'] as $file => $path) {
            $files[] = array(
              'file' => $file,
              'path' => $path,
              'enabled' => TRUE,
              'skin' => $skin,
              'options' => 0,
            );
          }
        }
        foreach ($info[$theme]->skins[$skin]['options'] as $option_id => $option) {
          if (isset($option['scripts'])) {
            foreach ($option['scripts'] as $file => $path) {
              $enabled = FALSE;
                if (is_array($classes)) {
                  if (in_array($option['class'], $classes)) {
                    $enabled = TRUE;
                  }
                }
                else {
                  if ($option['class'] == $classes) {
                    $enabled = TRUE;
                  }
                }

              $files[] = array(
                'file' => $file,
                'path' => $path,
                'enabled' => $enabled,
                'skin' => $skin,
                'options' => $option_id,
              );
            }
          }
        }
      }
    }
  }

  return $files;
}

/**
 * Helper function to add CSS and JS files to a page.
 *
 * This function uses drupal_add_css() and drupal_add_js() to add the files.
 *
 * @param $filename
 *   The name of the file to add.
 * @param $type
 *   The type of file. Options include: 'css' and 'js'.
 * @param $media
 *   (optional) The media type for the stylesheet, e.g., 'all', 'print',
 *   'screen'. Only required if $type is set to 'css'.
 */
function _skinr_add_file($filename, $type, $media = NULL) {
  if ($type == 'css') {
    drupal_add_css($filename, array('weight' => CSS_THEME, 'media' => $media));
  }
  else {
    drupal_add_js($filename, array('weight' => JS_THEME));
  }
}

/**
 * Helper function to flatten an array of classes settings.
 *
 * @param $skins
 *   The array of skins to flatten.
 *
 * @return
 *   An array of classes.
 */
function skinr_flatten_skins_array($skins) {
  $return = array();
  foreach ($skins as $entry) {
    if (is_array($entry)) {
      foreach ($entry as $subentry) {
        if (!empty($subentry)) {
          $return[] = check_plain($subentry);
        }
      }
    }
    elseif (!empty($entry)) {
      $return[] = check_plain($entry);
    }
  }

  return $return;
}

// ------------------------------------------------------------------
// Rule functions.

/**
 * Save a skinr rule object.
 *
 * @param $rule
 *   A rule object.
 *
 * @return
 *   The rule ID.
 */
function skinr_rule_save($rule) {
  drupal_write_record('skinr_rules', $rule, !empty($rule->rid) ? array('rid') : array());
  return $rule->rid;
}

/**
 * Load a skinr rule object.
 *
 * @param $rid
 *   (optional) The rule ID.
 *
 * @return
 *   A rule object. If no $rid is specified an array of all rules will be
 *   returned.
 */
function skinr_rule_load($rid = NULL) {
  $rids = (isset($rid) ? array($rid) : array());
  $rules = skinr_rule_load_multiple($rids);
  return $rules ? reset($rules) : FALSE;
}

/**
 * Loads multiple skinr rule objects.
 *
 * @param $rids
 *   An array of rule IDs. Optional.
 * @param $conditions
 *   An array of conditions on the {skinr_rules} table in the form 'field' =>
 *   $value.
 *
 * @return
 *   An array of rule objects indexed by rid. If $rids is not provided, all
 *   rules are returned.
 */
function skinr_rule_load_multiple($rids = array(), $conditions = array()) {
  $rules = array();
  $select = db_select('skinr_rules')->fields('skinr_rules');
  if (!empty($rids)) {
    $select->condition('rid', $rids);
  }
  foreach ($conditions as $field => $condition) {
    $select->condition($field, $condition);
  }
  foreach ($select->execute() as $rule) {
    $rule->roles = unserialize($rule->roles);
    $rules[$rule->rid] = $rule;
  }
  return $rules;
}

/**
 * Delete a skinr rule object.
 *
 * @param $rid
 *   The rule ID.
 */
function skinr_rule_delete($rid) {
  if ($rule = skinr_rule_load($rid)) {
    db_delete('skinr_rules')
      ->condition('rid', $rule->rid)
      ->execute();
    db_delete('skinr')
      ->condition('module', 'page')
      ->condition('sid', $rule->rid)
      ->execute();
  }
}

/**
 * Determine whether a rule is applies to the current page or not.
 *
 * @param $rid
 *   The rule ID.
 *
 * @todo Rename this function to skinr_rule_is_visible().
 */
function skinr_rule_visible($rid) {
  global $user;

  if ($rule = skinr_rule_load($rid)) {
    $page_match = TRUE;

    if (!empty($record['roles']) && ($user->uid != 1) && !count(array_intersect(array_keys($user->roles), $rule->roles))) {
      return FALSE;
    }

    // Match path if necessary
    if ($rule->pages) {
      if ($rule->visibility < 2) {
        $path = drupal_get_path_alias($_GET['q']);
        // Compare with the internal and path alias (if any).
        $page_match = drupal_match_path($path, $rule->pages);
        if ($path != $_GET['q']) {
          $page_match = $page_match || drupal_match_path($_GET['q'], $rule->pages);
        }
        // When $rule->visibility has a value of 0, the item is displayed on
        // all pages except those listed in $rule->pages. When set to 1, it
        // is displayed only on those pages listed in $rule->pages.
        $page_match = !($rule->visibility xor $page_match);
      }
      else {
        // PHP.
        if (module_exists('php')) {
          $page_match = php_eval($rule->pages);
        }
      }
    }
    return $page_match;
  }
  return FALSE;
}

// ------------------------------------------------------------------
// Include file helpers.

/**
 * Include files as necessary.
 *
 * @param $file
 *   The file to include. The filename needs to be prefixed with the
 *   implementing module's name (e.g. MODULE.$file), but do not include the
 *   module name prefix in your function call.
 */
function skinr_module_include($file) {
  foreach (skinr_get_module_apis() as $module => $info) {
    $filepath = DRUPAL_ROOT . "/$info[path]/$module.$file";
    if (file_exists($filepath)) {
      require_once $filepath;
    }
  }
}

/**
 * Get a list of modules that support skinr.
 */
function skinr_get_module_apis() {
  $cache = &drupal_static(__FUNCTION__, NULL);

  if (is_null($cache)) {
    $cache = array();
    foreach (module_implements('skinr_api') as $module) {
      $function = $module . '_skinr_api';
      $info = $function();
      if (isset($info['api']) && $info['api'] == 1.000) {
        if (!isset($info['path'])) {
          $info['path'] = drupal_get_path('module', $module);
        }
        $cache[$module] = $info;
      }
    }
  }

  return $cache;
}

// -----------------------------------------------------------------------
// Skinr data handling functions.

/**
 * Validate a skinr settings object.
 *
 * @param $skinr
 *   The skinr settings object to validate.
 *
 * @return
 *   TRUE on success, FALSE on failure.
 */
function skinr_validate(&$skinr) {
  if (!isset($skinr->theme) || !isset($skinr->module) || !isset($skinr->sid) || !isset($skinr->skins)) {
    return FALSE;
  }
  if (!isset($skinr->settings)) {
    $skinr->settings = array();
  }
  if (!is_array($skinr->skins) || !is_array($skinr->settings)) {
    return FALSE;
  }

  // Strip empty skins.
  $skinr->skins = _skinr_array_strip_empty($skinr->skins);

  return TRUE;
}

/**
 * Save a skinr settings object.
 *
 * @param $skinr
 *   A skinr object.
 *
 * @return
 *   TRUE on success, FALSE on failure.
 */
function skinr_set($skinr) {
  // Make sure we're getting valid data.
  if (!skinr_validate($skinr)) {
    return FALSE;
  }

  if (empty($skinr->skins) && empty($skinr->settings)) {
    // Delete the db entry if it exists.
    db_delete('skinr')
      ->condition('theme', $skinr->theme)
      ->condition('module', $skinr->module)
      ->condition('sid', $skinr->sid)
      ->execute();
  }
  else {
    // Let's save the data.
    if (skinr_get($skinr->theme, $skinr->module, $skinr->sid) !== FALSE) {
      // Record exists, so let's update.
      drupal_write_record('skinr', $skinr, array('theme', 'module', 'sid'));
    }
    else {
      // Insert a new record.
      drupal_write_record('skinr', $skinr);
    }
  }

  return TRUE;
}

/**
 * Retrieves the desired skinr settings object.
 *
 * @param $theme
 *   The theme these settings apply to. If no theme name is provided, the
 *   current theme will be used.
 * @param $module
 *   The module these settings apply to.
 * @param $sid
 *   The element ID these settings apply to.
 *
 * @return
 *   A skinr settings object if both $module and $sid are specified. An array
 *   of skinr settings objects if only $module is specified. An array of all
 *   skinr settings objects for a theme if neither $module nor $sid is
 *   specified. FALSE on failure.
 */
function skinr_get($theme = NULL, $module = NULL, $sid = NULL) {
  $cache = &drupal_static(__FUNCTION__, array());

  if (is_null($theme)) {
    $theme = skinr_current_theme();
  }

  if (!isset($cache[$theme][$module][$sid])) {
    if (!isset($cache[$theme])) {
      $cache[$theme] = array();
    }
    if (!is_null($module) && !isset($cache[$theme][$module])) {
      $cache[$theme][$module] = array();
    }

    if (!is_null($module) && !is_null($sid)) {
      // Fetch just this sid.
      $result = db_query("SELECT theme, module, sid, settings, skins FROM {skinr} WHERE theme = :theme AND module = :module AND sid = :sid", array(
        ':theme' => $theme,
        ':module' => $module,
        ':sid' => $sid,
      ));
    }
    elseif (!is_null($module)) {
      // Fetch all settings for this theme and module.
      $result = db_query("SELECT theme, module, sid, settings, skins FROM {skinr} WHERE theme = :theme AND module = :module", array(
        ':theme' => $theme,
        ':module' => $module,
      ));
    }
    else {
      // Fetch all settings for this theme.
      $result = db_query("SELECT theme, module, sid, settings, skins FROM {skinr} WHERE theme = :theme", array(
        ':theme' => $theme,
      ));
    }

    foreach ($result as $skinr) {
      $skinr->settings = unserialize($skinr->settings);
      $skinr->skins = unserialize($skinr->skins);
      $cache[$skinr->theme][$skinr->module][$skinr->sid] = $skinr;
    }
  }

  if (is_null($sid) && is_null($module)) {
    // Return all the skinrs for the theme.
    if (isset($cache[$theme])) {
      return $cache[$theme];
    }
  }
  elseif(is_null($sid)) {
    // Return all the skinrs for the module.
    if (isset($cache[$theme][$module])) {
      return $cache[$theme][$module];
    }
  }
  elseif (isset($cache[$theme][$module][$sid])) {
    return $cache[$theme][$module][$sid];
  }
  return FALSE;
}

/**
 * Helper function to remove empty skins from an array.
 *
 * @param $array
 *   A single or multi-dimensional array to strip of empty values.
 *
 * @return
 *   An array stripped of empty values.
 */
function _skinr_array_strip_empty($array) {
  $new_array = array();
  foreach ($array as $key => $value) {
    if (is_array($value)) {
      $value = _skinr_array_strip_empty($value);
    }
    if (!empty($value)) {
      $new_array[$key] = $value;
    }
  }
  return $new_array;
}

/**
 * Helper function to retrieve the current theme.
 *
 * The global variable $theme_key doesn't work for our purposes when an admin
 * theme is enabled.
 *
 * @param $exclude_admin_theme
 *   Optional. Set to TRUE to exclude the admin theme from possible themes to
 *   return.
 *
 * @return
 *   The current theme name.
 */
function skinr_current_theme($exclude_admin_theme = FALSE) {
  global $user, $custom_theme;

  if (!empty($user->theme) && drupal_theme_access($user->theme)) {
    $current_theme = $user->theme;
  }
  elseif (!empty($custom_theme) && drupal_theme_access($custom_theme) && !($exclude_admin_theme && $custom_theme == variable_get('admin_theme', '0'))) {
    // Don't return the admin theme if we're editing skinr settings.
    $current_theme = $custom_theme;
  }
  else {
    $current_theme = variable_get('theme_default', 'bartik');
  }
  return $current_theme;
}

/**
 * Prepare defaults for skinsets.
 *
 * @return
 *   An array of default skinset settings.
 */
function skinr_skins_default() {
  return array(
    'description' => '',
    'screenshot' => 'screenshot.png',
    'php' => DRUPAL_MINIMUM_PHP,
    'skinr' => array(),
  );
}

/**
 * Prepare defaults for groups.
 *
 * @return
 *   An array of default group settings.
 */
function skinr_group_default() {
  return array(
    'title' => '',
    'description' => '',
    'collapsible' => TRUE,
    'collapsed' => FALSE,
    'weight' => NULL,
  );
}

/**
 * Prepare defaults for skins.
 *
 * @return
 *   An array of default skin settings.
 */
function skinr_skin_default() {
  return array(
    'title' => '',
    'type' => 'checkboxes',
    'description' => '',
    'features' => array('*'),
    'group' => '',
    'options' => array(),
    'stylesheets' => array(),
    'scripts' => array(),
    'weight' => NULL,
  );
}

/**
 * Helper function to process a skin or theme .info file.
 *
 * @param $info
 *   An array of data as gotten from a skin or theme .info file.
 *
 * @return
 *    A processed set of skins.
 */
function _skinr_skinset($info) {
  $skinset = array(
    'options' => array('groups' => array()),
    'skins' => array(),
  );

  if (!empty($info->info['skinr'])) {
    $path_root = dirname($info->filename);

    $skinr_info = (array)$info->info['skinr'];

    // Store skinr options.
    if (!empty($skinr_info['options'])) {
      $skinset['options'] = $skinr_info['options'];
      unset($skinr_info['options']);

      if (!isset($skinset['options']['groups'])) {
        $skinset['options']['groups'] = array();
      }

      $defaults = skinr_group_default();
      foreach ($skinset['options']['groups'] as $id => $group) {
        $skinset['options']['groups'][$id] = array_merge($defaults, $skinset['options']['groups'][$id]);
        $skinset['options']['groups'][$id]['collapsible'] = (bool)$skinset['options']['groups'][$id]['collapsible'];
        $skinset['options']['groups'][$id]['collapsed'] = (bool)$skinset['options']['groups'][$id]['collapsed'];
        $skinset['options']['groups'][$id]['weight'] = $skinset['options']['groups'][$id]['weight'];
      }
    }

    $defaults = skinr_skin_default();

    foreach ($skinr_info as $id => $skin) {
      if (!is_array($skin)) {
        continue;
      }
      $skinset['skins'][$id] = array(
        'title' => isset($skin['title']) ? $skin['title'] : $defaults['title'],
        'type' => isset($skin['type']) ? $skin['type'] : $defaults['type'],
        'description' => isset($skin['description']) ? $skin['description'] : $defaults['description'],
        'features' => isset($skin['features']) ? $skin['features'] : $defaults['features'],
        'group' => !empty($skin['group']) && !empty($skinset['options']['groups'][$skin['group']]) ? $skin['group'] : $defaults['group'],
        'options' => isset($skin['options']) ? $skin['options'] : $defaults['options'],
        'stylesheets' => isset($skin['stylesheets']) ? $skin['stylesheets'] : $defaults['stylesheets'],
        'scripts' => isset($skin['scripts']) ? $skin['scripts'] : $defaults['scripts'],
        'weight' => isset($skin['weight']) ? $skin['weight'] : $defaults['weight'],
      );

      // Give the stylesheets proper path information.
      $skinset['skins'][$id]['stylesheets'] = _skinr_add_path_to_files($skinset['skins'][$id]['stylesheets'], $path_root, 'css');

      // Give the scripts proper path information.
      $skinset['skins'][$id]['scripts'] = _skinr_add_path_to_files($skinset['skins'][$id]['scripts'], $path_root, 'js');

      foreach ($skinset['skins'][$id]['options'] as $oid => $option) {
        if (isset($option['stylesheets'])) {
          $skinset['skins'][$id]['options'][$oid]['stylesheets'] = _skinr_add_path_to_files($option['stylesheets'], $path_root, 'css');
        }
        if (isset($option['scripts'])) {
          $skinset['skins'][$id]['options'][$oid]['scripts'] = _skinr_add_path_to_files($option['scripts'], $path_root, 'js');
        }
      }
    }
  }

  return $skinset;
}

/**
 * Helper function to prepend a path to an array of stylesheets or scripts in a
 * .info file.
 *
 * @param $files
 *   A an array of filenames that need the path prepended.
 * @param $path
 *   The path to prepend.
 * @param $type
 *   Either 'css' or 'js', depending on which files you wish to retrieve from
 *   these skins.
 *
 * @return
 *    An array of files with the root path added.
 */
function _skinr_add_path_to_files($files, $path, $type) {
  if ($type == 'css') {
    $pathed_stylesheets = array();
    foreach ($files as $media => $stylesheets) {
      foreach ($stylesheets as $stylesheet) {
        $pathed_stylesheets[$media][$stylesheet] = $path . '/' . $stylesheet;
      }
    }
    return $pathed_stylesheets;
  }
  elseif ($type == 'js') {
    $pathed_scripts = array();
    foreach ($files as $script) {
      $pathed_scripts[$script] = $path . '/' . $script;
    }
    return $pathed_scripts;
  }

  return FALSE;
}

/**
 * Helper function to process an array of skins.
 *
 * @return
 *    An array of skins.
 */
function skinr_skinsets() {
  $skinsets = &drupal_static(__FUNCTION__, array());

  if (!empty($skinsets)) {
    $result = db_query("SELECT * FROM {skinr_skinsets}");
    foreach ($result as $skinset) {
      if (file_exists($skinset->filename)) {
        $skinset->info = unserialize($skinset->info);
        $skinsets[$skinset->name] = $skinset;
      }
    }

    $themes = list_themes();
    $default_status = array();
    foreach ($themes as $theme) {
      $default_status[$theme->name] = $theme->name;
    }

    foreach ($skinsets as $key => $skinset) {
      if (isset($themes[$key])) {
        $skinset->type = 'theme';
        $skinset->status = !empty($theme->status) ? 1 : 0;
      }
      else {
        $skinset->type = 'skinset';
      }

      // @todo Allow skins to inherit from other skins.

      $additional = _skinr_skinset($skinset);
      $skinset->options = $additional['options'];
      $skinset->skins = $additional['skins'];

      $statuses = skinr_skinset_statuses($skinset->name);
      foreach ($skinset->skins as $skin_name => $skin) {
        $skinset->skins[$skin_name]['status'] = !empty($statuses[$skin_name]) ? $statuses[$skin_name] : $default_status;
      }
    }
  }

  return $skinsets;
}

/**
 * Return an array of statuses for each skin in a skinset for each theme.
 *
 * @param $skinset_name
 *   The name of the skinset for which to load the statuses.
 *
 * @return
 *   Array of statuses for individual skins in a skinset.
 */
function skinr_skinset_statuses($skinset_name) {
  $statuses = &drupal_static(__FUNCTION__, array());

  if (empty($statuses[$skinset_name])) {
    $statuses[$skinset_name] = array();

    $result = db_query("SELECT * FROM {skinr_skins} WHERE name = :name", array(':name' => $skinset_name));
    foreach ($result as $skinr_skin) {
      $statuses[$skinset_name][$skinr_skin->skin] = unserialize($skinr_skin->status);
    }
  }

  return $statuses[$skinset_name];
}

/**
 * Processes and compiles a list of all skins.
 *
 * @return
 *    An array of skinsets keyed by themename.
 *
 * @todo Use DB caching. No need to keep processing things every page load.
 */
function skinr_skin_data() {
  $cache = &drupal_static(__FUNCTION__);

  if (is_null($cache)) {
    $skinsets = skinr_skinsets();

    // Need to merge all skins skinsets into a single list of skins.
    // Also merge in the groups information.
    $additional_skins = array();
    $groups = array();
    foreach ($skinsets as $key => $skinset) {
      if ($skinset->type == 'skinset') {
        if (!empty($skinset->skins) && $skinset->status == 1) {
          $additional_skins += $skinset->skins;
        }
        if (!empty($skinset->options['groups'])) {
          $groups += $skinset->options['groups'];
        }
      }
    }

    // Merge the additional skins into each theme, even if that theme has no
    // skinr data.
    $themes = list_themes();
    foreach ($themes as $theme) {
      if ($theme->status != 1) {
        continue;
      }

      if (!empty($skinsets[$theme->name])) {
        $cache[$theme->name] = $skinsets[$theme->name];
        $cache[$theme->name]->skins += $additional_skins;
        $cache[$theme->name]->options['groups'] += $groups;
      }
      else {
        $cache[$theme->name] = new stdClass();
        $cache[$theme->name]->name = $theme->name;
        $cache[$theme->name]->status = 1;
        $cache[$theme->name]->type = 'theme';
        $cache[$theme->name]->skins = $additional_skins;
        $cache[$theme->name]->options = array('groups' => $groups);
      }
    }
  }

  return $cache;
}

/**
 * Fetch Skinr configuration data from Skinr functionality plugins.
 *
 * @return
 *   An array of all configuration data.
 */
function skinr_fetch_config() {
  $cache = &drupal_static(__FUNCTION__);

  if (is_null($cache)) {
    $cache = module_invoke_all('skinr_config');
    foreach (module_implements('skinr_config_alter') as $module) {
      $function = $module . '_skinr_config_alter';
      $function($cache);
    }
  }

  return $cache;
}

/**
 * Fetch default configuration data for Skinr functionality plugins.
 *
 * @param @setting
 *   The value 'form'. There are no other valid options.
 *
 * @return
 *   Returns an array of default values.
 *
 * @todo Remove the $setting parameter. There is only ever one option used:
 *  'form'.
 */
function _skinr_fetch_config_defaults($setting) {
  switch ($setting) {
    case 'form':
      $data = array(
        'access_handler' => 'skinr_access_handler',
        'index_handler' => 'skinr_index_handler',
        'data_handler' => 'skinr_data_handler',
        'submit_handler' => 'skinr_submit_handler',
        'submit_handler_attach_to' => array('#submit'),
        'skinr_title' => t('Skinr'),
        'skinr_weight' => 1,
        'title' => '',
        'description' => t('Manage which skins you want to apply to the hooks'),
        'collapsed' => TRUE,
        'weight' => 0,
      );
      return $data;
  }
}

/**
 * Execute a module's data handler.
 *
 * @param $type
 *   The type of handler to execute. Possible values:
 *   - 'access_handler':
 *   - 'contextual_links':
 *   - 'data_handler':
 *   - 'form_index_handler':
 *   - 'preprocess_index_handler':
 *   - 'preprocess_hook_callback':
 *   - 'submit_handler':
 * @param $op
 *   For 'access_handler' the possible values are 'access skinr'
 *     and 'access skinr classes'.
 *   For 'contextual_links' an empty string is passed.
 *   For 'data_handler' the possible values are 'form' and 'submit'.
 *   For 'form_index_handler' the possible values are 'form' and 'submit'.
 *   For 'preprocess_index_handler' the possible values are 'preprocess'.
 *   For 'preprocess_hook_callback' an empty string is passed.
 *   For 'submit_handler' an empty string is passed.
 * @param $handler
 *   The function name for this handler as gotten from skinr_fetch_config().
 * @param $a3
 *   For 'access_handler', passes in the $form parameter as provided to a form
 *     function.
 *   For 'contextual_links', passes in the $variables parameter from
 *     skinr_preprocess().
 *   For 'data_handler', passes in the $form parameter from hook_form_submit().
 *   For 'form_index_handler':
 *   - For $op 'form', passes in the $form parameter from hook_form_alter().
 *   - For $op 'submit', passes in the $form parameter from hook_form_submit().
 *   For 'preprocess_index_handler', passes in the $variables parameter from
 *     module_preprocess().
 *   For 'preprocess_hook_callback', passes in the $form parameter from
 *     hook_form_alter().
 *   For 'submit_handler', passes in the $form parameter from hook_form_alter().
 *
 * @param $a4
 *   For 'access_handler', passes in the $form_state array as provided to a
 *     form function.
 *   For 'data_handler', passes in the $form_state parameter form
 *     hook_form_submit().
 *   For 'form_index_handler':
 *   - For $op 'form', passes in the $form_state parameter from
 *     hook_form_alter().
 *   - For $op 'submit', passes in the $form_state parameter from
 *     hook_form_submit().
 *   For 'preprocess_hook_callback', passes in the $form_state parameter from
 *     hook_form_alter().
 *   For 'submit_handler', passes in the $form_state parameter from
 *     hook_form_alter().
 * @param $a5
 *   For 'data_handler', passes in the module that is currently being processed.
 *   For 'submit_handler', passes in the module that is currently being
 *     processed.
 * @param $a6
 *   For 'data_handler', passes in the settings from hook_skinr_config() for
 *     the form that's currently being processed.
 *   For 'submit_handler', passes in the settings from hook_skinr_config() for
 *     the form that's currently being processed.
 * @param $a7
 */
function skinr_handler($type, $op, $handler, &$a3, $a4 = NULL, $a5 = NULL, $a6 = NULL, $a7 = NULL) {
  if (is_callable($handler)) {
    switch ($type) {
      case 'contextual_links':
      case 'preprocess_index_handler':
        return $handler($a3);

      case 'preprocess_hook_callback':
        return $handler($a3, $a4);

      case 'data_handler':
      case 'submit_handler':
        return $handler($a3, $a4, $a5, $a6, $a7);

      default:
        return $handler($op, $a3, $a4);
    }
  }
}